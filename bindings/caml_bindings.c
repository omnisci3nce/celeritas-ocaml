/* automatically generated by ocaml-bindgen 0.0.1 */

#include "celeritas.h"
#include <caml/alloc.h>
#include <caml/callback.h>
#include <caml/fail.h>
#include <caml/memory.h>
#include <caml/mlvalues.h>
#include <caml/unixsupport.h>
void caml_core_bringup() {
  CAMLparam0();
  core_bringup();
  CAMLreturn0;
}

void caml_core_shutdown() {
  CAMLparam0();
  core_shutdown();
  CAMLreturn0;
}

bool caml_should_window_close() {
  CAMLparam0();
  CAMLlocal1(result);
  result = should_window_close();
  CAMLreturn(result);
}

vec2* caml_vec2_of_value(value caml_x) {
  vec2* x = malloc(sizeof(struct vec2));
  x->x = Double_val(Field(caml_x, 0));
  x->y = Double_val(Field(caml_x, 1));
  return x;
}

value caml_vec2_to_value(struct vec2* x) {
  CAMLparam0();
  CAMLlocal1(caml_x);
  caml_x = caml_alloc_tuple(2);
  Store_field(caml_x, 0, caml_copy_double(x->x));
  Store_field(caml_x, 1, caml_copy_double(x->y));
  CAMLreturn(caml_x);
}

vec3* caml_vec3_of_value(value caml_x) {
  vec3* x = malloc(sizeof(struct vec3));
  x->x = Double_val(Field(caml_x, 0));
  x->y = Double_val(Field(caml_x, 1));
  x->z = Double_val(Field(caml_x, 2));
  return x;
}

value caml_vec3_to_value(struct vec3* x) {
  CAMLparam0();
  CAMLlocal1(caml_x);
  caml_x = caml_alloc_tuple(3);
  Store_field(caml_x, 0, caml_copy_double(x->x));
  Store_field(caml_x, 1, caml_copy_double(x->y));
  Store_field(caml_x, 2, caml_copy_double(x->z));
  CAMLreturn(caml_x);
}

vec4* caml_vec4_of_value(value caml_x) {
  vec4* x = malloc(sizeof(struct vec4));
  x->x = Double_val(Field(caml_x, 0));
  x->y = Double_val(Field(caml_x, 1));
  x->z = Double_val(Field(caml_x, 2));
  x->w = Double_val(Field(caml_x, 3));
  return x;
}

value caml_vec4_to_value(struct vec4* x) {
  CAMLparam0();
  CAMLlocal1(caml_x);
  caml_x = caml_alloc_tuple(4);
  Store_field(caml_x, 0, caml_copy_double(x->x));
  Store_field(caml_x, 1, caml_copy_double(x->y));
  Store_field(caml_x, 2, caml_copy_double(x->z));
  Store_field(caml_x, 3, caml_copy_double(x->w));
  CAMLreturn(caml_x);
}

transform3d* caml_transform3d_of_value(value caml_x) {
  transform3d* x = malloc(sizeof(struct transform3d));
  x->translation = Int_val(Field(caml_x, 0));
  x->rotation = Int_val(Field(caml_x, 1));
  x->scale = Double_val(Field(caml_x, 2));
  return x;
}

value caml_transform3d_to_value(struct transform3d* x) {
  CAMLparam0();
  CAMLlocal1(caml_x);
  caml_x = caml_alloc_tuple(3);
  Store_field(caml_x, 0, Val_int(x->translation));
  Store_field(caml_x, 1, Val_int(x->rotation));
  Store_field(caml_x, 2, caml_copy_double(x->scale));
  CAMLreturn(caml_x);
}

void caml_render_frame_begin() {
  CAMLparam0();
  render_frame_begin();
  CAMLreturn0;
}

void caml_render_frame_draw() {
  CAMLparam0();
  render_frame_draw();
  CAMLreturn0;
}

void caml_render_frame_end() {
  CAMLparam0();
  render_frame_end();
  CAMLreturn0;
}

int caml_model_load(value caml_filepath) {
  CAMLparam1(caml_filepath);
  CAMLlocal1(result);
  char* filepath = Nativeint_val(Field(caml_filepath, 1));
  result = model_load(filepath);
  CAMLreturn(result);
}


#include <stdlib.h>
value bindgen_alloc(value caml_size) {
    CAMLparam1(caml_size);

    // Convert OCaml integer to C size
    size_t size = Int_val(caml_size);
    printf("Allocated size %ld \n", size);

    void* ptr = malloc(sizeof(size));
    if (ptr == NULL) {
        // TODO: handle allocation failure
        CAMLreturn(Val_unit);
    }
    
    // Wrap the pointer as an OCaml value
    CAMLreturn(caml_copy_nativeint(ptr));
}

void bindgen_free(value caml_addr) {
    free(Nativeint_val(caml_addr));
}

value bindgen_alloc_string(value caml_string) {
  CAMLparam1(caml_string);
    char* str = String_val(caml_string);
    CAMLreturn(caml_copy_nativeint((intnat)str));
}
